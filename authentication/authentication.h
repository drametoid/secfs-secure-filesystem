/*
* Authentication: Takes care of user authentication and access control.
*/

#ifndef AUTHENTICATION_H
#define AUTHENTICATION_H

#include <filesystem>
#include <fstream>
#include <iostream>
#include <random>
#include <regex>
#include <string>

enum UserType {
    admin = 0,
    user = 1
};

/// Check if a keyfile is valid
/// \param userName    The username to check
/// \return
bool isValidKeyfile(const std::string& userName)
{
    // Define paths for the user's private and public keys
    std::filesystem::path privateKeyPath = "key/private_keys/" + userName + "_keyfile";
    std::filesystem::path publicKeyPath = "key/public_keys/" + userName + ".pub";

    // Generate the expected public key from the private key file using ssh-keygen
    std::string extractPublicKeyCmd = "ssh-keygen -y -f " + privateKeyPath.string();
    std::array<char, 128> buffer;
    std::string expectedPublicKey;
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(extractPublicKeyCmd.c_str(), "r"), pclose);
    if (!pipe) {
        std::cerr << "Failed to run command: " << extractPublicKeyCmd << std::endl;
        return false;
    }
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        expectedPublicKey.append(buffer.data());
    }

    // Read the actual public key from file
    std::ifstream publicKeyFile(publicKeyPath);
    std::string actualPublicKey((std::istreambuf_iterator<char>(publicKeyFile)), std::istreambuf_iterator<char>());

    // Verify the public key is correctly generated by the system
    bool isCreatedByEncryptedFs = actualPublicKey.find("created_by_encrypted_fs") != std::string::npos;

    // Check if the user is listed in the system's user list
    bool isUserListed = false;
    std::ifstream userList("common/user_list");
    std::string line;
    while (getline(userList, line)) {
        if (line.find(userName) != std::string::npos) {
            isUserListed = true;
            break;
        }
    }
    // The keyfile is valid if the extracted public key matches the stored one, it's correctly flagged, and the user is listed
    return expectedPublicKey == actualPublicKey && isCreatedByEncryptedFs && isUserListed;
}

/// Get the type of user from a keyfile
/// \param keyFileName    The name of the keyfile
/// \return          The type of user
std::string getTypeOfUser(const std::string& keyFileName)
{
    // Attempt to get file status; if unsuccessful, terminate the program
    struct stat fileInfo;
    std::string privateKeyPath = "key/private_keys/" + keyFileName;
    if (stat(privateKeyPath.c_str(), &fileInfo) != 0) {
        std::cerr << "Invalid keyfile" << std::endl;
        exit(EXIT_FAILURE); // Consider throwing an exception instead of exiting
    }

    // Extract username from the keyfile name by removing the suffix and any spaces
    std::string userName = keyFileName.substr(0, keyFileName.find_first_of("_ "));

    // Validate the keyfile based on the extracted username
    if (isValidKeyfile(userName)) {
        std::cout << "Logged in as " << userName << std::endl;
        return userName;
    }

    // If validation fails, report an invalid keyfile and terminate the program
    std::cerr << "Invalid keyfile" << std::endl;
    exit(EXIT_FAILURE); // Consider throwing an exception instead of exiting
}



#endif // AUTHENTICATION_H
